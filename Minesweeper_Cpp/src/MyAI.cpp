// ======================================================================
// FILE:        MyAI.cpp
//
// AUTHOR:      Jian Li
//
// DESCRIPTION: This file contains your agent class, which you will
//              implement. You are responsible for implementing the
//              'getAction' function and any helper methods you feel you
//              need.
//
// NOTES:       - If you are having trouble understanding how the shell
//                works, look at the other parts of the code, as well as
//                the documentation.
//
//              - You are only allowed to make changes to this portion of
//                the code. Any changes to other portions of the code will
//                be lost when the tournament runs your code.
// ======================================================================

#include "MyAI.hpp"

MyAI::MyAI ( int _rowDimension, int _colDimension, int _totalMines, int _agentX, int _agentY ) : Agent()
{
    // ======================================================================
    // YOUR CODE BEGINS
    // ======================================================================
    rowDimension = _rowDimension;
    colDimension = _colDimension;
    totalMines = _totalMines ;
    agentX = _agentX;
    agentY = _agentY;
    
    startingX = agentX;
    startingY = agentY;
    
    vector<int> t = {agentX, agentY};
    safeUncovered.push_back(t);
  
    //initially all positions set to 9 (9 == COVERED)
    vector<vector<string>> tempBoard(rowDimension, vector<string>(colDimension, "*"));
                                 
    board = tempBoard;
    
    mineCount = 0;
  
    coveredTilesLeft = rowDimension * colDimension;
  
    //board.at(agentY).at(agentX) = "0";

    // ======================================================================
    // YOUR CODE ENDS
    // ======================================================================
};

Agent::Action MyAI::getAction( int number )
{
    // ======================================================================
    // YOUR CODE BEGINS
    // ======================================================================
  

//There is a folder in WorldGenerator called Problems that stores all the randomly generated Minesweeper Worlds (generated by the python script)
  //python3 WorldGenerator.py [numFiles] [filename] [rowDimension] [colDimension][numMines]
  //python3 WorldGenerator.py 1 easyN 5 5 1
  //python3 WorldGenerator.py 1 begin 8 8 10
//We can make the program run these worlds by ./bin/Minesweeper -f /app/WorldGenerator/Problems/begin1.txt
//Easy1.txt is a 5x5 world with 1 bomb
    
//     if (flagThese.size() != 0) {
//       int sz = flagThese.size();
//       int x = flagThese.at(sz - 1).at(0);
//       int y = flagThese.at(sz - 1).at(1);
//       flagThese.pop_back();
      
//       //update the agent location
//       agentX = x ;
//       agentY = y ;
      
//       return {FLAG, x , y };
//     }


  /* 
                        //easy logic
                      if (mineCount == totalMines) {
                        //uncover everything else (add them to safe) 

                        vector<int> temp;

                        for (int i = 0; i < board.size(); ++i) {
                          for (int j = 0; j < board.at(i).size(); ++j) {
                            if (board.at(i).at(j) == "*") {

                              temp.push_back(j);
                              temp.push_back(i);
                              if (find(safeUncovered.begin(), safeUncovered.end(), temp) == safeUncovered.end()) {
                                safe.push_back(temp);
                                safeUncovered.push_back(temp);
                              }

                              temp.clear();

                            }
                          }
                        }


                      }
                      */
  
  
    //part 2
    //get all the values at the frontier
    if(number != 0 && number != -1) {
      
      //store frontier in vector and work on frontier after all safe values are established

      vector<int> temp;

      temp.push_back(agentX);
      temp.push_back(agentY);


      if (find(frontier.begin(), frontier.end(), temp) == frontier.end()) {

        frontier.push_back(temp);

        //we have to store the number
        frontierNum.push_back(number);
      } 
    }
  

  
    //part 1
    //to prevent -1s from being put on board
    if (board.at(agentY).at(agentX) == "*") {
      board.at(agentY).at(agentX) = to_string(number);
    }
  
  
    printBoard();

  //solved the board
    if (totalMines == coveredTilesLeft) {
        

                if (safe.size() != 0) {

                  --coveredTilesLeft;
                  int sz = safe.size();
                  int x = safe.at(sz - 1).at(0);
                  int y = safe.at(sz - 1).at(1);
                  safe.pop_back();

                  /* NOTE THAT
                  THE TOP LEFT OF AN 8X8 BOARD IS(0,7)
                  The Manual AI Code has this line in its get action return statement: 

                  return {new_action, input_x - 1, input_y - 1};
                  */

                  //update the agent location
                  agentX = x ;
                  agentY = y ;

                  return {UNCOVER, x , y };
                }
      
      printBoard();
      cout << "HELO" << endl;
      return {LEAVE,-1,-1};
    }
  

    
  
    // Following an UNCOVER action, your argent will perceive the hint number
    // associated with the previous UNCOVER action. 
    // This number representshow many mines are within that tile’s immediate neighbors.

  
    //--coveredTilesLeft after each action
  
    //put safe coords into vector safe which is a vector of vector sz 2
    if (number == 0) {
      

      vector<int> temp;
      
      //safe vector will have all safe spots that need to be uncovered
      //safeUncovered vector will have all safe spots and uncovered spots 
      if (agentY + 1 < colDimension) {
        temp.push_back(agentX);
        temp.push_back(agentY + 1);
        
        //we don't want to double push a coord that is already stored in safe because it would double UNCOVER
        //from <algorithm>
        if (find(safeUncovered.begin(), safeUncovered.end(), temp) == safeUncovered.end()) {
          safe.push_back(temp);
          safeUncovered.push_back(temp);
        }
        
        temp.clear();
      }
      if (agentY - 1 >= 0) {
        temp.push_back(agentX);
        temp.push_back(agentY - 1);
        if (find(safeUncovered.begin(), safeUncovered.end(), temp) == safeUncovered.end()) {
          safe.push_back(temp);
          safeUncovered.push_back(temp);
        }
        temp.clear();
      }
      if (agentX - 1 >= 0) {
        temp.push_back(agentX - 1);
        temp.push_back(agentY);
        if (find(safeUncovered.begin(), safeUncovered.end(), temp) == safeUncovered.end()) {
          safe.push_back(temp);
          safeUncovered.push_back(temp);
        }
        temp.clear();
        
        if (agentY + 1 < colDimension) {
          temp.push_back(agentX - 1);
          temp.push_back(agentY + 1);
          if (find(safeUncovered.begin(), safeUncovered.end(), temp) == safeUncovered.end()) {
            safe.push_back(temp);
            safeUncovered.push_back(temp);
          }
        
          temp.clear();
        }
        if (agentY - 1 >= 0) {
          temp.push_back(agentX - 1);
          temp.push_back(agentY - 1);
          if (find(safeUncovered.begin(), safeUncovered.end(), temp) == safeUncovered.end()) {
            safe.push_back(temp);
            safeUncovered.push_back(temp);
          }
          temp.clear();
        }
      }
      if (agentX + 1 < rowDimension) {
        temp.push_back(agentX + 1);
        temp.push_back(agentY);
        if (find(safeUncovered.begin(), safeUncovered.end(), temp) == safeUncovered.end()) {
          safe.push_back(temp);
          safeUncovered.push_back(temp);
        }
        temp.clear();
        
        if (agentY + 1 < colDimension) {
          temp.push_back(agentX + 1);
          temp.push_back(agentY + 1);
          if (find(safeUncovered.begin(), safeUncovered.end(), temp) == safeUncovered.end()) {
            safe.push_back(temp);
            safeUncovered.push_back(temp);
          }
        
          temp.clear();
          
        }
        if (agentY - 1 >= 0) {
          temp.push_back(agentX + 1);
          temp.push_back(agentY - 1);
          if (find(safeUncovered.begin(), safeUncovered.end(), temp) == safeUncovered.end()) {
            safe.push_back(temp);
            safeUncovered.push_back(temp);
          }
        
          temp.clear();
        }
      }
    }
    
    //uncovers 1 per func call so
    if (safe.size() != 0) {
      
      --coveredTilesLeft;
      int sz = safe.size();
      int x = safe.at(sz - 1).at(0);
      int y = safe.at(sz - 1).at(1);
      safe.pop_back();

      /* NOTE THAT
      THE TOP LEFT OF AN 8X8 BOARD IS(0,7)
      The Manual AI Code has this line in its get action return statement: 

      return {new_action, input_x - 1, input_y - 1};
      */

      //update the agent location
      agentX = x ;
      agentY = y ;
      
      return {UNCOVER, x , y };
    }
  

    //part 2
    //we do this below because it happens after we uncover all the initial safe spaces
    if (frontier.size() != 0) {
      
      //in this loop we know that safe vector size is == 0 so all safe spaces marked
      
      //our frontier data collected in top
      //frontier.push_back(temp);
      //frontierNum.push_back(number);
      
      //index is index for both frontier and frontierNum as they are stored one after another
      int index = frontier.size() - 1;
      
      while (index >= 0) {
        
        int x = frontier.at(index).at(0);
        int y = frontier.at(index).at(1);
        
        int mineX = -1;
        int mineY = -1;

        if (frontierNum.at(index) == 1) {
          

          int numSq = 0;
          int numB = 0;

          if (y + 1 < colDimension) {

            if (board.at(y + 1).at(x) == "*") {
              numSq++;
              mineX = x;
              mineY = y + 1;
            }
            
              if (board.at(y + 1).at(x) == "B") {
                ++numB;
              }

          }
          if (y - 1 >= 0) {

            if (board.at(y - 1).at(x) == "*") {
              numSq++;
              mineX = x;
              mineY = y - 1;
            }
            
              if (board.at(y - 1).at(x) == "B") {
                ++numB;
              }

          }
          if (x - 1 >= 0) {

            if (board.at(y).at(x - 1) == "*") {
              numSq++;
              mineX = x - 1;
              mineY = y;
            }
            
              if (board.at(y).at(x - 1) == "B") {
                ++numB;
              }

            if (y + 1 < colDimension) {

              if (board.at(y + 1).at(x - 1) == "*") {
                numSq++;
                mineX = x - 1;
                mineY = y + 1;
              }
              
                if (board.at(y + 1).at(x - 1) == "B") {
                  ++numB;
                }

            }
            if (y - 1 >= 0) {

              if (board.at(y - 1).at(x - 1) == "*") {
                numSq++;
                mineX = x - 1;
                mineY = y - 1;
              }
              
                if (board.at(y - 1).at(x - 1) == "B") {
                  ++numB;
                }

            }
          }
          if (x + 1 < rowDimension) {

            if (board.at(y).at(x + 1) == "*") {
              numSq++;
              mineX = x + 1;
              mineY = y;
            }
            
              if (board.at(y).at(x + 1) == "B") {
                ++numB;
              }
            
            if (y + 1 < colDimension) {

              if (board.at(y + 1).at(x + 1) == "*") {
                numSq++;
                mineX = x + 1;
                mineY = y + 1;
              }
              
                if (board.at(y + 1).at(x + 1) == "B") {
                  ++numB;
                }

            }
            if (y - 1 >= 0) {

              if (board.at(y - 1).at(x + 1) == "*") {
                numSq++;
                mineX = x + 1;
                mineY = y - 1;
              }
              
                if (board.at(y - 1).at(x + 1) == "B") {
                  ++numB;
                }
              
            }
          }

          // cout << numSq << endl;

          if (numSq == 1 && numB == 0) {
            //then there is a mine at agentX + n and agentY + n and it will be correct because it was updated 1x
            //we don't have to flag it, just don't uncover
            //update our board 

            board.at(mineY).at(mineX) = "B";
            
            //we want to push back the neighborhood of the marked bomb B so we can do Effective Label calculations
              //vector<vector<int>> bNeighborhood;
                    vector<int> temp;
            
                    if (mineY + 1 < colDimension) {
                      temp.push_back(mineX);
                      temp.push_back(mineY + 1);


                      if (find(bNeighborhood.begin(), bNeighborhood.end(), temp) == bNeighborhood.end()) {
                        bNeighborhood.push_back(temp);
                      }

                      temp.clear();
                    }
                    if (mineY - 1 >= 0) {
                      temp.push_back(mineX);
                      temp.push_back(mineY - 1);
                      if (find(bNeighborhood.begin(), bNeighborhood.end(), temp) == bNeighborhood.end()) {
                        bNeighborhood.push_back(temp);
                      }
                      temp.clear();
                    }
                    if (mineX - 1 >= 0) {
                      temp.push_back(mineX - 1);
                      temp.push_back(mineY);
                      if (find(bNeighborhood.begin(), bNeighborhood.end(), temp) == bNeighborhood.end()) {
                        bNeighborhood.push_back(temp);
                      }
                      temp.clear();

                      if (mineY + 1 < colDimension) {
                        temp.push_back(mineX - 1);
                        temp.push_back(mineY + 1);
                        if (find(bNeighborhood.begin(), bNeighborhood.end(), temp) == bNeighborhood.end()) {
                          bNeighborhood.push_back(temp);
                        }

                        temp.clear();
                      }
                      if (mineY - 1 >= 0) {
                        temp.push_back(mineX - 1);
                        temp.push_back(mineY - 1);
                        if (find(bNeighborhood.begin(), bNeighborhood.end(), temp) == bNeighborhood.end()) {
                          bNeighborhood.push_back(temp);
                        }
                        temp.clear();
                      }
                    }
                    if (mineX + 1 < rowDimension) {
                      temp.push_back(mineX + 1);
                      temp.push_back(mineY);
                      if (find(bNeighborhood.begin(), bNeighborhood.end(), temp) == bNeighborhood.end()) {
                        bNeighborhood.push_back(temp);
                      }
                      temp.clear();

                      if (mineY + 1 < colDimension) {
                        temp.push_back(mineX + 1);
                        temp.push_back(mineY + 1);
                        if (find(bNeighborhood.begin(), bNeighborhood.end(), temp) == bNeighborhood.end()) {
                          bNeighborhood.push_back(temp);
                        }

                        temp.clear();

                      }
                      if (mineY - 1 >= 0) {
                        temp.push_back(mineX + 1);
                        temp.push_back(mineY - 1);
                        if (find(bNeighborhood.begin(), bNeighborhood.end(), temp) == bNeighborhood.end()) {
                          bNeighborhood.push_back(temp);
                        }
                        temp.clear();
                      }
                    }
            
            // //items to be flagged later
            // vector<int> flagVal;
            // flagVal.push_back(mineX);
            // flagVal.push_back(mineY);
            // flagThese.push_back(flagVal);

            --coveredTilesLeft;
            ++mineCount;
            
                      if (mineCount == totalMines) {
                        //uncover everything else (add them to safe) 

                        vector<int> temp;

                        for (int i = 0; i < board.size(); ++i) {
                          for (int j = 0; j < board.at(i).size(); ++j) {
                            if (board.at(i).at(j) == "*") {

                              temp.push_back(j);
                              temp.push_back(i);
                              if (find(safeUncovered.begin(), safeUncovered.end(), temp) == safeUncovered.end()) {
                                safe.push_back(temp);
                                safeUncovered.push_back(temp);
                              }

                              temp.clear();

                            }
                          }
                        }


                      }
          }

        }
        --index;
      }
      
          //also we should implement this logic EffectiveLabel(x) = Label(x) – NumMarkedNeighbors(x)
          /* if EffectiveLabel(x) = NumUnMarkedNeighbors(x), then
            all UnMarkedNeighbors(x) must be mines (mark them as
            such on the board; this is likely to reduce effective labels of
            other nearby uncovered tiles, so that the rules-of-thumb
            can be fired again)
            • E.g. if EffectiveLabel(x) = 0, then all UnMarkedNeighbors(x)
            must be safe (you can UNCOVER them) */
      
      
      
//       --coveredTilesLeft;
//       int sz = safe.size();
//       int x = frontier.at(sz - 1).at(0);
//       int y = frontier.at(sz - 1).at(1);
//       frontier.pop_back();

//       //update the agent location
//       agentX = x ;
//       agentY = y ;
      
//       return {UNCOVER, x , y };
      
              //When the number 1 has EXACTLY one empty square around it, then we know there’s a mine there.
    }
  
  
  
  
  
  
//END OF SUBMISSION 1 
  
    //effective label calculations
    //EffectiveLabel(x) = Label(x) – NumMarkedNeighbors(x)
    while (bNeighborhood.size() != 0) {
      
      int sz = bNeighborhood.size();
      int x = bNeighborhood.at(sz - 1).at(0);
      int y = bNeighborhood.at(sz - 1).at(1);
      
      //number at x y
      //board stores strings         so we convert it to int later
      string labelStr = board.at(y).at(x);
      
      //these values have a relevant Label value
      if (labelStr != "0" && labelStr != "*" && labelStr != "B") {
        
          //label num
          int label = stoi(labelStr);
          
        
          int effectiveLabel = effectiveLabelCalc(label, x, y);
          //find numMarkedNeighbors
          //vector<vector<int>> unmarkedNeighbors;

            // - if EffectiveLabel(x) = 0, then all UnMarkedNeighbors(x) must be safe (you can UNCOVER them)
            if (effectiveLabel == 0) {
              vector<int> temp;
              int sz;

              while (unmarkedNeighbors.size() != 0) {

                sz = unmarkedNeighbors.size();
                temp.push_back(unmarkedNeighbors.at(sz-1).at(0));
                temp.push_back(unmarkedNeighbors.at(sz-1).at(1));
                
                //if not already known as safe
                if (find(safeUncovered.begin(), safeUncovered.end(), temp) == safeUncovered.end()) {
                  safe.push_back(temp);
                  safeUncovered.push_back(temp);
                }

                unmarkedNeighbors.pop_back();
              }
              //unmarkedNeighbors should be cleared if this loop is executed
            }
            //
            
            // - if EffectiveLabel(x) = NumUnMarkedNeighbors(x), then all UnMarkedNeighbors(x) must be mines (mark them as
            // such on the board; this is likely to reduce effective labels of other nearby uncovered tiles, 
            // so that the rules-of-thumb can be fired again)
//             else if (effectiveLabel == numMarkedNeighbors) {
//                               //                               sz1 = 0;
//                               //                               x1 = -1;
//                               //                               y1 = -1;
//                               //board.at(mineY).at(mineX) = "B"
//                               while (unmarkedNeighbors.size() != 0) {

//                                 sz1 = unmarkedNeighbors.size();
//                                 int x1 = unmarkedNeighbors.at(sz1-1).at(0);
//                                 int y1 = unmarkedNeighbors.at(sz1-1).at(1);

//                                 board.at(y1).at(x1) = "B";
//                                             --coveredTilesLeft;
//                                             ++mineCount;
//                                   //!FIX!//
//                                  //we want to push back the neighborhood of the marked bomb B so we can do Effective Label calculations
//                                 //vector<vector<int>> bNeighborhood;
                                                  
//                                             vector<int> temp;

//                                             if (y1 + 1 < colDimension) {
//                                               temp.push_back(x1);
//                                               temp.push_back(y1 + 1);


//                                               if (find(bNeighborhood.begin(), bNeighborhood.end(), temp) == bNeighborhood.end()) {
//                                                 bNeighborhood.push_back(temp);
//                                               }

//                                               temp.clear();
//                                             }
//                                             if (y1 - 1 >= 0) {
//                                               temp.push_back(x1);
//                                               temp.push_back(y1 - 1);
//                                               if (find(bNeighborhood.begin(), bNeighborhood.end(), temp) == bNeighborhood.end()) {
//                                                 bNeighborhood.push_back(temp);
//                                               }
//                                               temp.clear();
//                                             }
//                                             if (x1 - 1 >= 0) {
//                                               temp.push_back(x1 - 1);
//                                               temp.push_back(y1);
//                                               if (find(bNeighborhood.begin(), bNeighborhood.end(), temp) == bNeighborhood.end()) {
//                                                 bNeighborhood.push_back(temp);
//                                               }
//                                               temp.clear();

//                                               if (y1 + 1 < colDimension) {
//                                                 temp.push_back(x1 - 1);
//                                                 temp.push_back(y1 + 1);
//                                                 if (find(bNeighborhood.begin(), bNeighborhood.end(), temp) == bNeighborhood.end()) {
//                                                   bNeighborhood.push_back(temp);
//                                                 }

//                                                 temp.clear();
//                                               }
//                                               if (y1 - 1 >= 0) {
//                                                 temp.push_back(x1 - 1);
//                                                 temp.push_back(y1 - 1);
//                                                 if (find(bNeighborhood.begin(), bNeighborhood.end(), temp) == bNeighborhood.end()) {
//                                                   bNeighborhood.push_back(temp);
//                                                 }
//                                                 temp.clear();
//                                               }
//                                             }
//                                             if (x1 + 1 < rowDimension) {
//                                               temp.push_back(x1 + 1);
//                                               temp.push_back(y1);
//                                               if (find(bNeighborhood.begin(), bNeighborhood.end(), temp) == bNeighborhood.end()) {
//                                                 bNeighborhood.push_back(temp);
//                                               }
//                                               temp.clear();

//                                               if (y1 + 1 < colDimension) {
//                                                 temp.push_back(x1 + 1);
//                                                 temp.push_back(y1 + 1);
//                                                 if (find(bNeighborhood.begin(), bNeighborhood.end(), temp) == bNeighborhood.end()) {
//                                                   bNeighborhood.push_back(temp);
//                                                 }

//                                                 temp.clear();

//                                               }
//                                               if (y1 - 1 >= 0) {
//                                                 temp.push_back(x1 + 1);
//                                                 temp.push_back(y1 - 1);
//                                                 if (find(bNeighborhood.begin(), bNeighborhood.end(), temp) == bNeighborhood.end()) {
//                                                   bNeighborhood.push_back(temp);
//                                                 }
//                                                 temp.clear();
//                                               }
//                                             }
                                
//                                             //dont double push
//                                 unmarkedNeighbors.pop_back();
//                               }

              

//               }
                
          //} while (effectiveLabel == numMarkedNeighbors && effectiveLabel != 0);
        

          
        }
      
      
            unmarkedNeighbors.clear();


            // The ABOVE is likely to reduce effective labels of other nearby uncovered tiles, 
            // so that the rules-of-thumb can be fired again)
            // if (effectiveLabel != numMarkedNeighbors) {
            //   bNeighborhood.pop_back();
            // }
            bNeighborhood.pop_back();

    }

}

//calculates effective label given label and x y coordinate
int MyAI::effectiveLabelCalc(int label, int x1, int y1) {
          vector<int> temp;
        
          int numMarkedNeighbors = 0;
        

          int effectiveLabel = 0;
          // int sz1 = 0;
          // int x1 = -1;
          // int y1 = -1;
          // - if EffectiveLabel(x) = NumUnMarkedNeighbors(x), then all UnMarkedNeighbors(x) must be mines (mark them as
          // such on the board; this is likely to reduce effective labels of other nearby uncovered tiles, 
          // so that the rules-of-thumb can be fired again)

          //label remains the same (int label)
          //do {  
                    
                                                    if (y1 + 1 < colDimension) {

                                                      if (board.at(y1 + 1).at(x1) == "B") {
                                                        numMarkedNeighbors++;
                                                      }

                                                      if (board.at(y1 + 1).at(x1) == "*") {
                                                        temp.push_back(x1);
                                                        temp.push_back(y1+1);
                                                        //we don't have to check if we already pushed back the same value 
                                                        //into unmarkedNeighbors because we are going to clear it at the end of the loop
                                                        unmarkedNeighbors.push_back(temp);
                                                        temp.clear();
                                                      }

                                                    }
                                                    if (y1 - 1 >= 0) {
                                                      if (board.at(y1 - 1).at(x1) == "B") {
                                                        numMarkedNeighbors++;
                                                      }
                                                      if (board.at(y1 - 1).at(x1) == "*") {
                                                        temp.push_back(x1);
                                                        temp.push_back(y1-1);
                                                        unmarkedNeighbors.push_back(temp);
                                                        temp.clear();
                                                      }
                                                    }
                                                    if (x1 - 1 >= 0) {
                                                      if (board.at(y1).at(x1 - 1) == "B") {
                                                        numMarkedNeighbors++;
                                                      }
                                                      if (board.at(y1).at(x1 - 1) == "*") {
                                                        temp.push_back(x1-1);
                                                        temp.push_back(y1);
                                                        unmarkedNeighbors.push_back(temp);
                                                        temp.clear();
                                                      }

                                                      if (y1 + 1 < colDimension) {
                                                        if (board.at(y1 + 1).at(x1 - 1) == "B") {
                                                          numMarkedNeighbors++;
                                                        }
                                                        if (board.at(y1 + 1).at(x1 - 1) == "*") {
                                                          temp.push_back(x1-1);
                                                          temp.push_back(y1+1);
                                                          unmarkedNeighbors.push_back(temp);
                                                          temp.clear();
                                                        }
                                                      }
                                                      if (y1 - 1 >= 0) {
                                                        if (board.at(y1 - 1).at(x1 - 1) == "B") {
                                                          numMarkedNeighbors++;
                                                        }
                                                        if (board.at(y1 - 1).at(x1 - 1) == "*") {
                                                          temp.push_back(x1-1);
                                                          temp.push_back(y1-1);
                                                          unmarkedNeighbors.push_back(temp);
                                                          temp.clear();
                                                        }
                                                      }
                                                    }
                                                    if (x1 + 1 < rowDimension) {
                                                      if (board.at(y1).at(x1 + 1) == "B") {
                                                        numMarkedNeighbors++;
                                                      }
                                                      if (board.at(y1).at(x1 + 1) == "*") {
                                                        temp.push_back(x1+1);
                                                        temp.push_back(y1);
                                                        unmarkedNeighbors.push_back(temp);
                                                        temp.clear();
                                                      }

                                                      if (y1 + 1 < colDimension) {
                                                        if (board.at(y1 + 1).at(x1 + 1) == "B") {
                                                          numMarkedNeighbors++;
                                                        }
                                                        if (board.at(y1 + 1).at(x1 + 1) == "*") {
                                                          temp.push_back(x1+1);
                                                          temp.push_back(y1+1);
                                                          unmarkedNeighbors.push_back(temp);
                                                          temp.clear();
                                                        }

                                                      }
                                                      if (y1 - 1 >= 0) {
                                                        if (board.at(y1 - 1).at(x1 + 1) == "B") {
                                                          numMarkedNeighbors++;
                                                        }
                                                        if (board.at(y1 - 1).at(x1 + 1) == "*") {
                                                          temp.push_back(x1+1);
                                                          temp.push_back(y1-1);
                                                          unmarkedNeighbors.push_back(temp);
                                                          temp.clear();
                                                        }
                                                      }
                                                    }
            
            effectiveLabel = label - numMarkedNeighbors;
  
  return effectiveLabel;
}



//NOTE that the board prints 0 - sz-1 from bottom to top / left to right
void MyAI::printBoard() {
    cout << "---------------- Game Board ------------------\n" << endl;
    cout << "RowDimension: " << rowDimension << endl << "ColDimension: " << colDimension << endl;
    cout << "Starting X/Y: " << startingX << " " << startingY << endl;
    for (int i = colDimension - 1; i >= 0; i--) {
      for (int j = 0; j < rowDimension; j++) {
        cout << board.at(i).at(j);
      }
      cout << endl;
    }

}


// ======================================================================
// YOUR CODE BEGINS
// ======================================================================
// ======================================================================
// YOUR CODE ENDS
// ======================================================================


    // ======================================================================
    // YOUR CODE ENDS
    // ======================================================================