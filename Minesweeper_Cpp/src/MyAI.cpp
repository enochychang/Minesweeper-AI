// ======================================================================
// FILE:        MyAI.cpp
//
// AUTHOR:      Jian Li
//
// DESCRIPTION: This file contains your agent class, which you will
//              implement. You are responsible for implementing the
//              'getAction' function and any helper methods you feel you
//              need.
//
// NOTES:       - If you are having trouble understanding how the shell
//                works, look at the other parts of the code, as well as
//                the documentation.
//
//              - You are only allowed to make changes to this portion of
//                the code. Any changes to other portions of the code will
//                be lost when the tournament runs your code.
// ======================================================================

#include "MyAI.hpp"

MyAI::MyAI ( int _rowDimension, int _colDimension, int _totalMines, int _agentX, int _agentY ) : Agent()
{
    // ======================================================================
    // YOUR CODE BEGINS
    // ======================================================================
    rowDimension = _rowDimension;
    colDimension = _colDimension;
    totalMines = _totalMines ;
    agentX = _agentX;
    agentY = _agentY;
    
    startingX = agentX;
    startingY = agentY;
    
    vector<int> t = {agentX, agentY};
    safeUncovered.push_back(t);
  
    //initially all positions set to 9 (9 == COVERED)
    vector<vector<string>> tempBoard(rowDimension, vector<string>(colDimension, "*"));
                                 
    board = tempBoard;
    
    mineCount = 0;
    //board.at(agentY).at(agentX) = "0";

    // ======================================================================
    // YOUR CODE ENDS
    // ======================================================================
};

Agent::Action MyAI::getAction( int number )
{
    // ======================================================================
    // YOUR CODE BEGINS
    // ======================================================================
  

//There is a folder in WorldGenerator called Problems that stores all the randomly generated Minesweeper Worlds (generated by the python script)
//We can make the program run these worlds by ./bin/Minesweeper -f /app/WorldGenerator/Problems/easy1.txt
//Easy1.txt is a 5x5 world with 1 bomb
    
//     if (flagThese.size() != 0) {
//       int sz = flagThese.size();
//       int x = flagThese.at(sz - 1).at(0);
//       int y = flagThese.at(sz - 1).at(1);
//       flagThese.pop_back();
      
//       //update the agent location
//       agentX = x ;
//       agentY = y ;
      
//       return {FLAG, x , y };
//     }
  
    //part 2
    //get all the values at the frontier
    if(number != 0 && number != -1) {
      
      //store frontier in vector and work on frontier after all safe values are established

      vector<int> temp;

      temp.push_back(agentX);
      temp.push_back(agentY);


      if (find(frontier.begin(), frontier.end(), temp) == frontier.end()) {

        frontier.push_back(temp);

        //we have to store the number
        frontierNum.push_back(number);
      }

        
        
    }
  

  
    //part 1
    //to prevent -1s from being put on board
    if (board.at(agentY).at(agentX) == "*") {
      board.at(agentY).at(agentX) = to_string(number);
    }
  
  
  //printBoard();


    if (totalMines == coveredTilesLeft) {
      
      // printBoard();
      cout << "HILO" << endl;
      
      return {LEAVE,-1,-1};
    }
  

    
  
    // Following an UNCOVER action, your argent will perceive the hint number
    // associated with the previous UNCOVER action. 
    // This number representshow many mines are within that tile’s immediate neighbors.

  
    //--coveredTilesLeft after each action
  
    //put safe coords into vector safe which is a vector of vector sz 2
    if (number == 0) {
      

      vector<int> temp;
      
      //safe vector will have all safe spots that need to be uncovered
      //safeUncovered vector will have all safe spots and uncovered spots 
      if (agentY + 1 < colDimension) {
        temp.push_back(agentX);
        temp.push_back(agentY + 1);
        
        //we don't want to double push a coord that is already stored in safe because it would double UNCOVER
        //from <algorithm>
        if (find(safeUncovered.begin(), safeUncovered.end(), temp) == safeUncovered.end()) {
          safe.push_back(temp);
          safeUncovered.push_back(temp);
        }
        
        temp.clear();
      }
      if (agentY - 1 >= 0) {
        temp.push_back(agentX);
        temp.push_back(agentY - 1);
        if (find(safeUncovered.begin(), safeUncovered.end(), temp) == safeUncovered.end()) {
          safe.push_back(temp);
          safeUncovered.push_back(temp);
        }
        temp.clear();
      }
      if (agentX - 1 >= 0) {
        temp.push_back(agentX - 1);
        temp.push_back(agentY);
        if (find(safeUncovered.begin(), safeUncovered.end(), temp) == safeUncovered.end()) {
          safe.push_back(temp);
          safeUncovered.push_back(temp);
        }
        temp.clear();
        
        if (agentY + 1 < colDimension) {
          temp.push_back(agentX - 1);
          temp.push_back(agentY + 1);
          if (find(safeUncovered.begin(), safeUncovered.end(), temp) == safeUncovered.end()) {
            safe.push_back(temp);
            safeUncovered.push_back(temp);
          }
        
          temp.clear();
        }
        if (agentY - 1 >= 0) {
          temp.push_back(agentX - 1);
          temp.push_back(agentY - 1);
          if (find(safeUncovered.begin(), safeUncovered.end(), temp) == safeUncovered.end()) {
            safe.push_back(temp);
            safeUncovered.push_back(temp);
          }
          temp.clear();
        }
      }
      if (agentX + 1 < rowDimension) {
        temp.push_back(agentX + 1);
        temp.push_back(agentY);
        if (find(safeUncovered.begin(), safeUncovered.end(), temp) == safeUncovered.end()) {
          safe.push_back(temp);
          safeUncovered.push_back(temp);
        }
        temp.clear();
        
        if (agentY + 1 < colDimension) {
          temp.push_back(agentX + 1);
          temp.push_back(agentY + 1);
          if (find(safeUncovered.begin(), safeUncovered.end(), temp) == safeUncovered.end()) {
            safe.push_back(temp);
            safeUncovered.push_back(temp);
          }
        
          temp.clear();
          
        }
        if (agentY - 1 >= 0) {
          temp.push_back(agentX + 1);
          temp.push_back(agentY - 1);
          if (find(safeUncovered.begin(), safeUncovered.end(), temp) == safeUncovered.end()) {
            safe.push_back(temp);
            safeUncovered.push_back(temp);
          }
        
          temp.clear();
        }
      }
    }
    
    //uncovers 1 per func call so
    if (safe.size() != 0) {
      
      --coveredTilesLeft;
      int sz = safe.size();
      int x = safe.at(sz - 1).at(0);
      int y = safe.at(sz - 1).at(1);
      safe.pop_back();

      /* NOTE THAT
      THE TOP LEFT OF AN 8X8 BOARD IS(0,7)
      The Manual AI Code has this line in its get action return statement: 

      return {new_action, input_x - 1, input_y - 1};
      */

      //update the agent location
      agentX = x ;
      agentY = y ;
      
      return {UNCOVER, x , y };
    }
  

    //part 2
    //we do this below because it happens after we uncover all the initial safe spaces
    if (frontier.size() != 0) {
      
      //in this loop we know that safe vector size is == 0 so all safe spaces marked
      
      //our frontier data collected in top
      //frontier.push_back(temp);
      //frontierNum.push_back(number);
      
      //index is index for both frontier and frontierNum as they are stored one after another
      int index = frontier.size() - 1;
      
      while (index >= 0) {
        
        int x = frontier.at(index).at(0);
        int y = frontier.at(index).at(1);
        
        int mineX = -1;
        int mineY = -1;

        if (frontierNum.at(index) == 1) {
          

          int numSq = 0;
          int numB = 0;

          if (y + 1 < colDimension) {

            if (board.at(y + 1).at(x) == "*") {
              numSq++;
              mineX = x;
              mineY = y + 1;
            }
            
              if (board.at(y + 1).at(x) == "B") {
                ++numB;
              }

          }
          if (y - 1 >= 0) {

            if (board.at(y - 1).at(x) == "*") {
              numSq++;
              mineX = x;
              mineY = y - 1;
            }
            
              if (board.at(y - 1).at(x) == "B") {
                ++numB;
              }

          }
          if (x - 1 >= 0) {

            if (board.at(y).at(x - 1) == "*") {
              numSq++;
              mineX = x - 1;
              mineY = y;
            }
            
              if (board.at(y).at(x - 1) == "B") {
                ++numB;
              }

            if (y + 1 < colDimension) {

              if (board.at(y + 1).at(x - 1) == "*") {
                numSq++;
                mineX = x - 1;
                mineY = y + 1;
              }
              
                if (board.at(y + 1).at(x - 1) == "B") {
                  ++numB;
                }

            }
            if (y - 1 >= 0) {

              if (board.at(y - 1).at(x - 1) == "*") {
                numSq++;
                mineX = x - 1;
                mineY = y - 1;
              }
              
                if (board.at(y - 1).at(x - 1) == "B") {
                  ++numB;
                }

            }
          }
          if (x + 1 < rowDimension) {

            if (board.at(y).at(x + 1) == "*") {
              numSq++;
              mineX = x + 1;
              mineY = y;
            }
            
              if (board.at(y).at(x + 1) == "B") {
                ++numB;
              }
            
            if (y + 1 < colDimension) {

              if (board.at(y + 1).at(x + 1) == "*") {
                numSq++;
                mineX = x + 1;
                mineY = y + 1;
              }
              
                if (board.at(y + 1).at(x + 1) == "B") {
                  ++numB;
                }

            }
            if (y - 1 >= 0) {

              if (board.at(y - 1).at(x + 1) == "*") {
                numSq++;
                mineX = x + 1;
                mineY = y - 1;
              }
              
                if (board.at(y - 1).at(x + 1) == "B") {
                  ++numB;
                }
              
            }
          }

          // cout << numSq << endl;

          if (numSq == 1 && numB == 0) {
            //then there is a mine at agentX + n and agentY + n and it will be correct because it was updated 1x
            //we don't have to flag it, just don't uncover
            //update our board 

            board.at(mineY).at(mineX) = "B";
            
            // //items to be flagged later
            // vector<int> flagVal;
            // flagVal.push_back(mineX);
            // flagVal.push_back(mineY);
            // flagThese.push_back(flagVal);

            --coveredTilesLeft;
            ++mineCount;
            
                      if (mineCount == totalMines) {
                        //uncover everything else (add them to safe) 

                        vector<int> temp;

                        for (int i = 0; i < board.size(); ++i) {
                          for (int j = 0; j < board.at(i).size(); ++j) {
                            if (board.at(i).at(j) == "*") {

                              temp.push_back(j);
                              temp.push_back(i);
                              if (find(safeUncovered.begin(), safeUncovered.end(), temp) == safeUncovered.end()) {
                                safe.push_back(temp);
                                safeUncovered.push_back(temp);
                              }

                              temp.clear();

                            }
                          }
                        }


                      }
          }

        }
        --index;
      }
      
          //also we should implement this logic EffectiveLabel(x) = Label(x) – NumMarkedNeighbors(x)
          /* if EffectiveLabel(x) = NumUnMarkedNeighbors(x), then
            all UnMarkedNeighbors(x) must be mines (mark them as
            such on the board; this is likely to reduce effective labels of
            other nearby uncovered tiles, so that the rules-of-thumb
            can be fired again)
            • E.g. if EffectiveLabel(x) = 0, then all UnMarkedNeighbors(x)
            must be safe (you can UNCOVER them) */
      
      
      
//       --coveredTilesLeft;
//       int sz = safe.size();
//       int x = frontier.at(sz - 1).at(0);
//       int y = frontier.at(sz - 1).at(1);
//       frontier.pop_back();

//       //update the agent location
//       agentX = x ;
//       agentY = y ;
      
//       return {UNCOVER, x , y };
      
              //When the number 1 has EXACTLY one empty square around it, then we know there’s a mine there.
    }

}





//NOTE that the board prints 0 - sz-1 from bottom to top / left to right
void MyAI::printBoard() {
    cout << "---------------- Game Board ------------------\n" << endl;
    cout << "RowDimension: " << rowDimension << endl << "ColDimension: " << colDimension << endl;
    cout << "Starting X/Y: " << startingX << " " << startingY << endl;
    for (int i = colDimension - 1; i >= 0; i--) {
      for (int j = 0; j < rowDimension; j++) {
        cout << board.at(i).at(j);
      }
      cout << endl;
    }

}


// ======================================================================
// YOUR CODE BEGINS
// ======================================================================
// ======================================================================
// YOUR CODE ENDS
// ======================================================================


    // ======================================================================
    // YOUR CODE ENDS
    // ======================================================================